<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 0.34.0">
<meta name="crystal_docs.project_version" content="master">
<meta name="crystal_docs.project_name" content="crysda">


<link href="css/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="js/doc.js"></script>

<svg class="hidden">
  <symbol id="octicon-link" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
  </symbol>
</svg>

  <meta id="repository-name" content="crysda">
  <title>crysda master</title>
  <script type="text/javascript">
  CrystalDocs.base_path = "";
  </script>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="project-summary">
      <h1 class="project-name">
        <a href="index.html">
          crysda
        </a>
      </h1>

      <span class="project-version">
        master
      </span>
    </div>
  </div>

  <div class="search-results" class="hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class="parent " data-id="crysda/Crysda" data-name="crysda">
      <a href="Crysda.html">Crysda</a>
      
        <ul>
  
  <li class=" " data-id="crysda/Crysda/AggFunc" data-name="crysda::aggfunc">
      <a href="Crysda/AggFunc.html">AggFunc</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/AggFuncs" data-name="crysda::aggfuncs">
      <a href="Crysda/AggFuncs.html">AggFuncs</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/Any" data-name="crysda::any">
      <a href="Crysda/Any.html">Any</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/AnyCol" data-name="crysda::anycol">
      <a href="Crysda/AnyCol.html">AnyCol</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/AnyVal" data-name="crysda::anyval">
      <a href="Crysda/AnyVal.html">AnyVal</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/BoolCol" data-name="crysda::boolcol">
      <a href="Crysda/BoolCol.html">BoolCol</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/ColNames" data-name="crysda::colnames">
      <a href="Crysda/ColNames.html">ColNames</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/ColSpec" data-name="crysda::colspec">
      <a href="Crysda/ColSpec.html">ColSpec</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/ColumnException" data-name="crysda::columnexception">
      <a href="Crysda/ColumnException.html">ColumnException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/ColumnFormula" data-name="crysda::columnformula">
      <a href="Crysda/ColumnFormula.html">ColumnFormula</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/ColumnNotFoundException" data-name="crysda::columnnotfoundexception">
      <a href="Crysda/ColumnNotFoundException.html">ColumnNotFoundException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/ColumnSelector" data-name="crysda::columnselector">
      <a href="Crysda/ColumnSelector.html">ColumnSelector</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/CrysdaException" data-name="crysda::crysdaexception">
      <a href="Crysda/CrysdaException.html">CrysdaException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/CustomColumnValue" data-name="crysda::customcolumnvalue">
      <a href="Crysda/CustomColumnValue.html">CustomColumnValue</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/DataCol" data-name="crysda::datacol">
      <a href="Crysda/DataCol.html">DataCol</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/DataFrame" data-name="crysda::dataframe">
      <a href="Crysda/DataFrame.html">DataFrame</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/DataFrameRow" data-name="crysda::dataframerow">
      <a href="Crysda/DataFrameRow.html">DataFrameRow</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/DFCol" data-name="crysda::dfcol">
      <a href="Crysda/DFCol.html">DFCol</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/DuplicateColumnNameException" data-name="crysda::duplicatecolumnnameexception">
      <a href="Crysda/DuplicateColumnNameException.html">DuplicateColumnNameException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/Float64Col" data-name="crysda::float64col">
      <a href="Crysda/Float64Col.html">Float64Col</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/HashBuilder" data-name="crysda::hashbuilder">
      <a href="Crysda/HashBuilder.html">HashBuilder</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/Int32Col" data-name="crysda::int32col">
      <a href="Crysda/Int32Col.html">Int32Col</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/Int64Col" data-name="crysda::int64col">
      <a href="Crysda/Int64Col.html">Int64Col</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/InvalidColumnOperationException" data-name="crysda::invalidcolumnoperationexception">
      <a href="Crysda/InvalidColumnOperationException.html">InvalidColumnOperationException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/InvalidColumnSelectException" data-name="crysda::invalidcolumnselectexception">
      <a href="Crysda/InvalidColumnSelectException.html">InvalidColumnSelectException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/InvalidSortingPredicateException" data-name="crysda::invalidsortingpredicateexception">
      <a href="Crysda/InvalidSortingPredicateException.html">InvalidSortingPredicateException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/List" data-name="crysda::list(t)">
      <a href="Crysda/List.html">List</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/MissingValueException" data-name="crysda::missingvalueexception">
      <a href="Crysda/MissingValueException.html">MissingValueException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/NonScalarValueException" data-name="crysda::nonscalarvalueexception">
      <a href="Crysda/NonScalarValueException.html">NonScalarValueException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/RenamePair" data-name="crysda::renamepair">
      <a href="Crysda/RenamePair.html">RenamePair</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/RenameRule" data-name="crysda::renamerule">
      <a href="Crysda/RenameRule.html">RenameRule</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/RowPredicate" data-name="crysda::rowpredicate">
      <a href="Crysda/RowPredicate.html">RowPredicate</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/SelectException" data-name="crysda::selectexception">
      <a href="Crysda/SelectException.html">SelectException</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/SortExpression" data-name="crysda::sortexpression">
      <a href="Crysda/SortExpression.html">SortExpression</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/StringCol" data-name="crysda::stringcol">
      <a href="Crysda/StringCol.html">StringCol</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/SumFormula" data-name="crysda::sumformula">
      <a href="Crysda/SumFormula.html">SumFormula</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/SummarizeFunc" data-name="crysda::summarizefunc">
      <a href="Crysda/SummarizeFunc.html">SummarizeFunc</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/TableExpression" data-name="crysda::tableexpression">
      <a href="Crysda/TableExpression.html">TableExpression</a>
      
    </li>
  
  <li class=" " data-id="crysda/Crysda/UnSupportedOperationException" data-name="crysda::unsupportedoperationexception">
      <a href="Crysda/UnSupportedOperationException.html">UnSupportedOperationException</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<h1><a id="crys-da" class="anchor" href="#crys-da">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>CrysDA</h1>

<p><a href="https://github.com/naqvis/CrysDA/actions?query=workflow%3ACrysDA%20CI" target="_blank"><img src="https://github.com/naqvis/CrysDA/workflows/CrysDA%20CI/badge.svg" alt="CI"/></a>
<a href="https://github.com/naqvis/CrysDA/releases" target="_blank"><img src="https://img.shields.io/github/release/naqvis/CrysDA.svg" alt="Latest release"/></a>
<a href="https://naqvis.github.io/CrysDA/" target="_blank"><img src="https://img.shields.io/badge/docs-available-brightgreen.svg" alt="Docs"/></a></p>

<p><code>CrysDA</code> is a <strong>Crys</strong>tal shard for <strong>D</strong>ata <strong>A</strong>nalysis. Provides you modern functional-style API for data manipulation to filter, transform, aggregate and reshape tabular data. Core of the library is <code><a href="Crysda/DataFrame.html">Crysda::DataFrame</a></code> an immutable data structure interface.</p>

<p><code>CrysDA</code> is heavily inspired by the amazing <a href="https://github.com/hadley/dplyr" target="_blank"><code>dplyr</code></a> for <a href="https://www.r-project.org/" target="_blank">R</a>. <code>CrysDA</code> is written in pure Crystal and have no external dependencies. It is mimicking the API of <code>dplyr</code>, while carefully adding more typed constructs where possible.</p>

<h2><a id="features" class="anchor" href="#features">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Features</h2>

<ul><li>[X] Filter, transform, aggregate and reshape tabular data</li><li>[X] Modern, user-friendly and easy-to-learn data-science API</li><li>[X] Reads from plain and compressed tsv, csv, json, or any delimited format with or without header from local or remote with auto inferring the types of data.</li><li>[X] Supports reading data from DB</li><li>[X] Supports grouped operations</li><li>[X] Tables can contain atomic columns (Number, Float, Bool, String) as well as object columns</li><li>[X] Reshape tables from wide to long and back</li><li>[X] Table joins (left, right, semi, inner, outer)</li><li>[X] Cross tabulation</li><li>[X] Descriptive statistics (mean, min, max, median, ...)</li><li>[X] Functional API inspired by <a href="http://dplyr.tidyverse.org/" target="_blank">dplyr</a>, <a href="http://pandas.pydata.org/" target="_blank">pandas</a></li></ul>

<ul><li>[X] many more...</li></ul>

<h2><a id="quick-glimpse-and-comparison-with-rdplyr" class="anchor" href="#quick-glimpse-and-comparison-with-rdplyr">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Quick glimpse and comparison with R/dplyr</h2>

<pre><code class="language-crystal">flights <span class="o">=</span> <span class="t">Crysda</span>.read_csv(<span class="s">&quot;./spec/data/nycflights.tsv.gz&quot;</span>, separator: <span class="s">&#39;\t&#39;</span>)

flights
.group_by(<span class="s">&quot;year&quot;</span>, <span class="s">&quot;month&quot;</span>, <span class="s">&quot;day&quot;</span>)
.<span class="k">select</span>(
  <span class="t">Crysda</span>.selector { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;year&quot;</span>..<span class="s">&quot;day&quot;</span>] }, <span class="c"># columns range</span>
  <span class="t">Crysda</span>.selector { <span class="o">|</span>e<span class="o">|</span> e.list_of(<span class="s">&quot;arr_delay&quot;</span>, <span class="s">&quot;dep_delay&quot;</span>) })
.summarize(
  <span class="s">&quot;mean_arr_delay&quot;</span>.<span class="k">with</span> {<span class="o">|</span>s<span class="o">|</span> s[<span class="s">&quot;arr_delay&quot;</span>].mean(remove_na: <span class="n">true</span>)},
  <span class="s">&quot;mean_dep_delay&quot;</span>.<span class="k">with</span> {<span class="o">|</span>s<span class="o">|</span> s[<span class="s">&quot;dep_delay&quot;</span>].mean(<span class="n">true</span>)})
.filter {<span class="o">|</span>f<span class="o">|</span> (f[<span class="s">&quot;mean_arr_delay&quot;</span>] <span class="o">&gt;</span> <span class="n">30</span>) .or (f[<span class="s">&quot;mean_dep_delay&quot;</span>] <span class="o">&gt;</span> <span class="n">30</span>)}
.print(<span class="s">&quot;Flights mean delay of arrival and departure)</span></code></pre>

<p><strong>output</strong></p>

<pre><code class="language-shell">Flights mean delay of arrival and departure: 49 x 5
     year   month   day   mean_arr_delay   mean_dep_delay
 1   2013       1    16           34.247           24.613
 2   2013       1    31           32.603           28.658
 3   2013      10     7           39.017           39.147
 4   2013      10    11           18.923           31.232
 5   2013      12     5           51.666           52.328
 6   2013      12     8           36.912           21.515
 7   2013      12     9           42.576           34.800
 8   2013      12    10           44.509           26.465
 9   2013      12    14           46.398           28.362
10   2013      12    17           55.872           40.706
and 39 more rows</code></pre>

<p><strong>And the same snippet written in <code>dplyr</code></strong></p>

<pre><code class="language-r">flights %>%
    group_by(year, month, day) %>%
    select(year:day, arr_delay, dep_delay) %>%
    summarise(
        mean_arr_delay = mean(arr_delay, na.rm = TRUE),
        mean_dep_delay = mean(dep_delay, na.rm = TRUE)
    ) %>%
    filter(mean_arr_delay > 30 | mean_dep_delay > 30)</code></pre>

<hr/><h2><a id="tutorial-short-1-minute-introduction" class="anchor" href="#tutorial-short-1-minute-introduction">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Tutorial - Short 1 minute Introduction</h2>

<p>For this quick and short tutorial, we will be using <a href="https://www.kaggle.com/residentmario/ramen-ratings" target="_blank">ramen-ratings</a> dataset from kaggle. You are free to use any of your choice.</p>

<pre><code class="language-crystal"><span class="c"># load dataset</span>
df <span class="o">=</span> <span class="t">Crysda</span>.read_csv(<span class="s">&quot;./spec/data/ramen-ratings.csv&quot;</span>)</code></pre>

<p>Shard provide support for loading data from CSV, TSV, JSON, DB, URL etc and auto infer the types of columns by peeking into data and make a best choice of data type. Once we’ve read the data into a DataFrame, we can start poking it to see what it looks like. A couple of things one typically look at first are the schema and a few rows.</p>

<pre><code class="language-crystal">df.print(max_rows: <span class="n">5</span>) <span class="c"># just show us first 5 rows of data</span></code></pre>

<pre><code class="language-shell">A DataFrame: 2580 x 7
    Review #            Brand                                                       Variety   Style   Country   Stars   Top Ten
1       2580        New Touch                                     T's Restaurant Tantanmen      Cup     Japan    3.75
2       2579         Just Way   Noodles Spicy Hot Sesame Spicy Hot Sesame Guan-miao Noodles    Pack    Taiwan       1
3       2578           Nissin                                 Cup Noodles Chicken Vegetable     Cup       USA    2.25
4       2577          Wei Lih                                 GGE Ramen Snack Tomato Flavor    Pack    Taiwan    2.75
5       2576   Ching's Secret                                               Singapore Curry    Pack     India    3.75
and 2575 more rows</code></pre>

<p>above output shows that our dataset contains 2580 observations (rows) with 7 variables (or they are called columns here)</p>

<pre><code class="language-crystal">df.schema <span class="c"># show the structure of data.</span></code></pre>

<pre><code class="language-shell">DataFrame with 2580 observations
Review # [Int32]  2580, 2579, 2578, 2577, 2576, 2575, 2574, 2573, 2572, 2571, 2570, 2569, 2568, 2567, 2566, 2565, 2564...
Brand    [String] New Touch, Just Way, Nissin, Wei Lih, Ching's Secret, Samyang Foods, Acecook, Ikeda Shoku, Ripe'n'Dr...
Variety  [String] T's Restaurant Tantanmen , Noodles Spicy Hot Sesame Spicy Hot Sesame Guan-miao Noodles, Cup Noodles ...
Style    [String] Cup, Pack, Cup, Pack, Pack, Pack, Cup, Tray, Pack, Pack, Pack, Pack, Pack, Bowl, Pack, Cup, Pack, Pa...
Country  [String] Japan, Taiwan, USA, Taiwan, India, South Korea, Japan, Japan, Japan, Singapore, Thailand, USA, South...
Stars    [String] 3.75, 1, 2.25, 2.75, 3.75, 4.75, 4, 3.75, 0.25, 2.5, 5, 5, 4.25, 4.5, 5, 3.5, 3.75, 5, 4, 4, 4.25, 5...
Top Ten  [String] , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ...</code></pre>

<p>Already at this point we can notice that for some reason, the ratings (<code>Stars</code> column) themselves inferred to be of <code>String</code> type. That might be due to some weirdness in the data itself. Exploring various datasets you’ll encounter all sorts of strange things. Some are easy to fix, like in this case. Let's try to see what is causing the problem</p>

<pre><code class="language-crystal">df.count(<span class="s">&quot;Stars&quot;</span>).print(max_rows: <span class="n">15</span>)</code></pre>

<pre><code class="language-shell">A DataFrame: 51 x 2
       Stars     n
 1      3.75   350
 2         1    26
 3      2.25    21
 4      2.75    85
 5      4.75    64
 6         4   384
 7      0.25    11
 8       2.5    67
 9         5   369
10      4.25   143
11       4.5   132
12       3.5   326
13   Unrated     3
14       1.5    37
15      3.25   170
and 36 more rows</code></pre>

<p>Turns out three records have a rating of “Unrated”, and since there are so few of them, it’s easier to just drop those records or we can reload the dataset and set the <code>na_value</code> argument to <code>"Unrated"</code>, entries with this value will then be treated as <code>nil</code>. use this approach if you want to treat some values as nil, or you don't want to lose other columns values.</p>

<pre><code class="language-crystal">df <span class="o">=</span> <span class="t">Crysda</span>.read_csv(<span class="s">&quot;./spec/data/ramen-ratings.csv&quot;</span>, na_value: <span class="s">&quot;Unrated&quot;</span>) <span class="c"># this will retain all rows, while column values with &quot;Unrated&quot; will be treated as `nil`</span></code></pre>

<p>But in this tutorial we are just going to drop those 3 rows and addd new column to dataframe loaded in above step.</p>

<pre><code class="language-crystal">new_df <span class="o">=</span> df.filter { <span class="o">|</span>f<span class="o">|</span> f[<span class="s">&quot;Stars&quot;</span>].matching { <span class="o">|</span>s<span class="o">|</span> <span class="o">!</span>s.starts_with?(<span class="s">&quot;Un&quot;</span>) } }
  .add_column(<span class="s">&quot;Stars_New&quot;</span>) { <span class="o">|</span>c<span class="o">|</span> c[<span class="s">&quot;Stars&quot;</span>].map { <span class="o">|</span>m<span class="o">|</span> m.to_s.to_f } }.tap(<span class="o">&amp;</span>.schema)</code></pre>

<pre><code class="language-shell">DataFrame with 2577 observations
Review #  [Int32]   2580, 2579, 2578, 2577, 2576, 2575, 2574, 2573, 2572, 2571, 2570, 2569, 2568, 2567, 2566, 2565, 2564...
Brand     [String]  New Touch, Just Way, Nissin, Wei Lih, Ching's Secret, Samyang Foods, Acecook, Ikeda Shoku, Ripe'n'Dr...
Variety   [String]  T's Restaurant Tantanmen , Noodles Spicy Hot Sesame Spicy Hot Sesame Guan-miao Noodles, Cup Noodles ...
Style     [String]  Cup, Pack, Cup, Pack, Pack, Pack, Cup, Tray, Pack, Pack, Pack, Pack, Pack, Bowl, Pack, Cup, Pack, Pa...
Country   [String]  Japan, Taiwan, USA, Taiwan, India, South Korea, Japan, Japan, Japan, Singapore, Thailand, USA, South...
Stars     [String]  3.75, 1, 2.25, 2.75, 3.75, 4.75, 4, 3.75, 0.25, 2.5, 5, 5, 4.25, 4.5, 5, 3.5, 3.75, 5, 4, 4, 4.25, 5...
Top Ten   [String]  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ...
Stars_New [Float64] 3.750, 1.000, 2.250, 2.750, 3.750, 4.750, 4.000, 3.750, 0.250, 2.500, 5.000, 5.000, 4.250, 4.500, 5....</code></pre>

<p>So we added a new column <code>Stars_New</code> and we can see that its now of <code>Float64</code> type. We can perform simple statistics operations on this column now. Let's just calculate the average rating.</p>

<pre><code class="language-crystal"><span class="c"># we can either create summary dataframe</span>
new_df.summarize(<span class="s">&quot;Average Rating&quot;</span>.<span class="k">with</span> {<span class="o">|</span>c<span class="o">|</span> c[<span class="s">&quot;Stars_New&quot;</span>].mean}).tap(<span class="o">&amp;</span>.print)
<span class="c"># or we can store the value to some local variable</span>
puts new_df[<span class="s">&quot;Stars_New&quot;</span>].mean <span class="c"># =&gt; 3.654675979821498</span></code></pre>

<p>Of course, you can have questions to your data that can require some data manipulation, like grouping. For example, let’s find out how many unique Ramen brands are there per country.</p>

<pre><code class="language-crystal">brands_per_country <span class="o">=</span> new_df
.group_by(<span class="s">&quot;Country&quot;</span>)
.distinct(<span class="s">&quot;Brand&quot;</span>)
.group_by(<span class="s">&quot;Country&quot;</span>)
.count.tap(<span class="o">&amp;</span>.print)</code></pre>

<pre><code class="language-shell">A DataFrame: 31 x 2
         Country    n
 1         Japan   58
 2        Taiwan   47
 3           USA   44
 4         India    7
 5   South Korea   32
 6     Singapore    5
 7      Thailand   22
 8     Hong Kong    9
 9       Vietnam   14
10         Ghana    2
and 21 more rows</code></pre>

<p>Let's sort the dataframe on unique brand count in descending order (with highest count on top)</p>

<pre><code class="language-crystal">brands_per_country.sort_desc_by(<span class="s">&quot;n&quot;</span>).print</code></pre>

<pre><code class="language-shell">A DataFrame: 31 x 2
         Country    n
 1         Japan   58
 2        Taiwan   47
 3           USA   44
 4   South Korea   32
 5      Malaysia   28
 6         China   22
 7      Thailand   22
 8     Indonesia   18
 9       Vietnam   14
10            UK   11
and 21 more rows</code></pre>

<p>These were just a very few and basic examples to give you a taste of what you can do with <code><a href="Crysda.html">Crysda</a></code>. As every data wrangler’s path is different, I would encourage you to grab a dataset that interests you and explore it.</p>

<hr/><h2><a id="tutorial-2-reshaping-data" class="anchor" href="#tutorial-2-reshaping-data">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Tutorial 2 - Reshaping Data</h2>

<p>Data analysis can be divided into three parts</p>

<ul><li>Extraction : First, we need to collect the data from many sources and combine them.</li><li>Transform: This step involves the data manipulation. Once we have consolidated all the sources of data, we can begin to clean the data.</li><li>Visualize: The last move is to visualize our data to check irregularity.</li></ul>

<p>One of the most significant challenges faced by data scientist is the data manipulation. Data is never available in the desired format. The data scientist needs to spend at least half of his time, cleaning and manipulating the data. That is one of the most critical assignments in the job. If the data manipulation process is not complete, precise and rigorous, the model will not perform correctly.</p>

<h3><a id="mergingjoining-data" class="anchor" href="#mergingjoining-data">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Merging(joining) Data</h3>

<p>CrysDA provides a nice and convenient way to combine datasets. We may have many sources of input data, and at some point, we need to combine them. A join with CrysDA adds variables to the right of the original dataset. The beauty is CrysDA is that it handles four types of joins similar to SQL</p>

<ul><li>Left join</li><li>right join</li><li>inner join</li><li>outer join</li></ul>

<p>We will study all the joins types via an easy example.</p>

<p>First of all, we build two datasets. Table 1 contains two variables, ID, and y, whereas Table 2 gathers ID and z. In each situation, we need to have a key-pair variable. In our case, ID is our key variable. The function will look for identical values in both tables and bind the returning values to the right of table 1.
<img src="images/table1.png" alt="Table 1"/></p>

<pre><code class="language-crystal">df_primary <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;ID&quot;</span>,<span class="s">&quot;y&quot;</span>).values(
  <span class="s">&quot;A&quot;</span>, <span class="n">5</span>,
   <span class="s">&quot;B&quot;</span>, <span class="n">5</span>,
   <span class="s">&quot;C&quot;</span>, <span class="n">8</span>,
   <span class="s">&quot;D&quot;</span>, <span class="n">0</span>,
  <span class="s">&quot;F&quot;</span>, <span class="n">9</span>
)

df_secondary <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;ID&quot;</span>,<span class="s">&quot;z&quot;</span>).values(
  <span class="s">&quot;A&quot;</span>, <span class="n">30</span>,
   <span class="s">&quot;B&quot;</span>, <span class="n">21</span>,
   <span class="s">&quot;C&quot;</span>, <span class="n">22</span>,
   <span class="s">&quot;D&quot;</span>, <span class="n">25</span>,
   <span class="s">&quot;E&quot;</span>, <span class="n">29</span>
)</code></pre>

<h4><a id="left-join" class="anchor" href="#left-join">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>left_join()</h4>

<p>The most common way to merge two datasets is to use the <code>left_join</code> function. We can see from the picture below that the key-pair matches perfectly the rows A, B, C and D from both datasets. However, E and F are left over. How do we treat these two observations? With the <code>left_join</code>, we will keep all the variables in the original table and don't consider the variables that do not have a key-paired in the destination table. In our example, the variable E does not exist in table 1. Therefore, the row will be dropped. The variable F comes from the origin table; it will be kept after the <code>left_join</code> and return NA in the column z. The figure below reproduces what will happen with a <code>left_join</code>.
<img src="images/left_join.png" alt="Left Join"/></p>

<pre><code class="language-crystal">df_primary.left_join(df_secondary, <span class="s">&quot;ID&quot;</span>).print(<span class="s">&quot;Left Join&quot;</span>)</code></pre>

<p>Output:</p>

<pre><code class="language-shell">Left Join: 5 x 3
    ID   y      z
1    A   5     30
2    B   5     21
3    C   8     22
4    D   0     25
5    F   9   &lt;NA></code></pre>

<h4><a id="right-join" class="anchor" href="#right-join">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>right_join()</h4>

<p>The <code>right_join</code> function works exactly like <code>left_join</code>. The only difference is the row dropped. The value E, available in the destination data frame, exists in the new table and takes the value NA for the column y.
<img src="images/right_join.png" alt="Right Join"/></p>

<pre><code class="language-crystal">df_primary.right_join(df_secondary, <span class="s">&quot;ID&quot;</span>).print(<span class="s">&quot;Right Join&quot;</span>)</code></pre>

<p>Output:</p>

<pre><code class="language-shell">Right Join: 5 x 3
    ID      y    z
1    A      5   30
2    B      5   21
3    C      8   22
4    D      0   25
5    E   &lt;NA>   29</code></pre>

<h4><a id="inner-join" class="anchor" href="#inner-join">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>inner_join()</h4>

<p>When we are 100% sure that the two datasets won't match, we can consider to return only rows existing in both dataset. This is possible when we need a clean dataset or when we don't want to impute missing values with the mean or median.</p>

<p>The <code>inner_join</code> comes to help. This function excludes the unmatched rows.
<img src="images/inner_join.png" alt="Inner Join"/></p>

<pre><code class="language-crystal">df_primary.inner_join(df_secondary, <span class="s">&quot;ID&quot;</span>).print(<span class="s">&quot;Inner Join&quot;</span>)</code></pre>

<p>Output:</p>

<pre><code class="language-shell">Inner Join: 4 x 3
    ID   y    z
1    A   5   30
2    B   5   21
3    C   8   22
4    D   0   25</code></pre>

<h4><a id="outer-join" class="anchor" href="#outer-join">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>outer_join()</h4>

<p>Finally, the <code>outer_join</code> function keeps all observations and replace missing values with <code>NA</code>.
<img src="images/outer_join.png" alt="Outer Join"/></p>

<pre><code class="language-crystal">df_primary.outer_join(df_secondary, <span class="s">&quot;ID&quot;</span>).print(<span class="s">&quot;Outer Join&quot;</span>)</code></pre>

<p>Output:</p>

<pre><code class="language-shell">Outer Join: 6 x 3
    ID      y      z
1    A      5     30
2    B      5     21
3    C      8     22
4    D      0     25
5    E   &lt;NA>     29
6    F      9   &lt;NA></code></pre>

<h4><a id="multiple-keys-pairs" class="anchor" href="#multiple-keys-pairs">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Multiple keys pairs</h4>

<p>We can have multiple keys in our dataset. Consider the following dataset where we have a years or a list of products bought by the customer.
<img src="images/multikey_join.png" alt="Duplicate keys"/></p>

<pre><code class="language-crystal">df_primary <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;ID&quot;</span>,<span class="s">&quot;year&quot;</span>,<span class="s">&quot;items&quot;</span>).values(
  <span class="s">&quot;A&quot;</span>, <span class="n">2015</span>,<span class="n">3</span>,
  <span class="s">&quot;A&quot;</span>, <span class="n">2016</span>,<span class="n">7</span>,
  <span class="s">&quot;A&quot;</span>, <span class="n">2017</span>,<span class="n">6</span>,
  <span class="s">&quot;B&quot;</span>, <span class="n">2015</span>,<span class="n">4</span>,
  <span class="s">&quot;B&quot;</span>, <span class="n">2016</span>,<span class="n">8</span>,
  <span class="s">&quot;B&quot;</span>, <span class="n">2017</span>,<span class="n">7</span>,
  <span class="s">&quot;C&quot;</span>, <span class="n">2015</span>,<span class="n">4</span>,
  <span class="s">&quot;C&quot;</span>, <span class="n">2016</span>,<span class="n">6</span>,
  <span class="s">&quot;C&quot;</span>, <span class="n">2017</span>,<span class="n">6</span>
)

df_secondary <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;ID&quot;</span>,<span class="s">&quot;year&quot;</span>,<span class="s">&quot;prices&quot;</span>).values(
  <span class="s">&quot;A&quot;</span>, <span class="n">2015</span>,<span class="n">9</span>,
  <span class="s">&quot;A&quot;</span>, <span class="n">2016</span>,<span class="n">8</span>,
  <span class="s">&quot;A&quot;</span>, <span class="n">2017</span>,<span class="n">12</span>,
  <span class="s">&quot;B&quot;</span>, <span class="n">2015</span>,<span class="n">13</span>,
  <span class="s">&quot;B&quot;</span>, <span class="n">2016</span>,<span class="n">14</span>,
  <span class="s">&quot;B&quot;</span>, <span class="n">2017</span>,<span class="n">6</span>,
  <span class="s">&quot;C&quot;</span>, <span class="n">2015</span>,<span class="n">15</span>,
  <span class="s">&quot;C&quot;</span>, <span class="n">2016</span>,<span class="n">15</span>,
  <span class="s">&quot;C&quot;</span>, <span class="n">2017</span>,<span class="n">13</span>
)

df_primary.left_join(df_secondary, by: [<span class="s">&quot;ID&quot;</span>,<span class="s">&quot;year&quot;</span>]).print(<span class="s">&quot;Multikey Join&quot;</span>)</code></pre>

<p>Output:</p>

<pre><code class="language-shell">Multikey Join: 9 x 4
    ID   year   items   prices
1    A   2015       3        9
2    A   2016       7        8
3    A   2017       6       12
4    B   2015       4       13
5    B   2016       8       14
6    B   2017       7        6
7    C   2015       4       15
8    C   2016       6       15
9    C   2017       6       13</code></pre>

<h3><a id="data-cleaning-functions" class="anchor" href="#data-cleaning-functions">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Data Cleaning functions</h3>

<p>Following are four important functions to tidy the data:</p>

<ul><li>gather: Transform the data from wide to long</li><li>spread: Transform the data from long to wide</li><li>separate: Split one variable into multiples</li><li>unite: Unite multiple variables into one</li></ul>

<h4><a id="gather" class="anchor" href="#gather">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>gather()</h4>

<p>The objectives of the <code>gather</code> function is to transform the data from wide to long.</p>

<p>Below we can visualize the concept of reshaping wide to long. We want to create a single column named growth, filled by the rows of the quarter variables.
<img src="images/gather.png" alt="gather"/></p>

<pre><code class="language-crystal"><span class="c"># Create a dataset</span>
df <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;country&quot;</span>, <span class="s">&quot;q1_2017&quot;</span>, <span class="s">&quot;q2_2017&quot;</span>, <span class="s">&quot;q3_2017&quot;</span>, <span class="s">&quot;q4_2017&quot;</span>).values(
  <span class="s">&quot;A&quot;</span>, <span class="n">0.03</span>, <span class="n">0.05</span>, <span class="n">0.04</span>, <span class="n">0.03</span>,
  <span class="s">&quot;B&quot;</span>, <span class="n">0.05</span>, <span class="n">0.07</span>, <span class="n">0.05</span>, <span class="n">0.02</span>,
  <span class="s">&quot;C&quot;</span>, <span class="n">0.01</span>, <span class="n">0.02</span>, <span class="n">0.01</span>, <span class="n">0.04</span>)
df.print</code></pre>

<p>Output:</p>

<pre><code class="language-shell">A DataFrame: 3 x 5
    country   q1_2017   q2_2017   q3_2017   q4_2017
1         A     0.030     0.050     0.040     0.030
2         B     0.050     0.070     0.050     0.020
3         C     0.010     0.020     0.010     0.040</code></pre>

<p>Reshape the data</p>

<pre><code class="language-crystal">reshaped <span class="o">=</span> df.gather(<span class="s">&quot;quarter&quot;</span>,<span class="s">&quot;growth&quot;</span>, <span class="t">Crysda</span>.selector{<span class="o">|</span>c<span class="o">|</span> c[<span class="s">&quot;q1_2017&quot;</span>..<span class="s">&quot;q4_2017&quot;</span>]}).tap(<span class="o">&amp;</span>.print(max_rows: <span class="n">12</span>))</code></pre>

<p>Output:</p>

<pre><code class="language-shell">A DataFrame: 12 x 3
     country   quarter   growth
 1         A   q1_2017    0.030
 2         B   q1_2017    0.050
 3         C   q1_2017    0.010
 4         A   q2_2017    0.050
 5         B   q2_2017    0.070
 6         C   q2_2017    0.020
 7         A   q3_2017    0.040
 8         B   q3_2017    0.050
 9         C   q3_2017    0.010
10         A   q4_2017    0.030
11         B   q4_2017    0.020
12         C   q4_2017    0.040</code></pre>

<p>In the <code>gather</code> function, we created two new variables <strong>qurater</strong> and <strong>growth</strong> because our original dataset has one group variable: <strong>country</strong> and the key-value pairs.</p>

<h4><a id="spread" class="anchor" href="#spread">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>spread()</h4>

<p>The <code>spread</code> function does the opposite of <code>gather</code>. We can reshape data in above example back to its original form.</p>

<pre><code class="language-crystal">reshaped.spread(<span class="s">&quot;quarter&quot;</span>,<span class="s">&quot;growth&quot;</span>).print</code></pre>

<p>Output:</p>

<pre><code class="language-shell">A DataFrame: 3 x 5
    country   q1_2017   q2_2017   q3_2017   q4_2017
1         A     0.030     0.050     0.040     0.030
2         B     0.050     0.070     0.050     0.020
3         C     0.010     0.020     0.010     0.040</code></pre>

<h4><a id="separate" class="anchor" href="#separate">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>separate()</h4>

<p>The <code>separate</code> function splits a column into multiples according to a separator. This function is helpful in some situations where the variable is a list of values seprated by a separator. For example, our analysis require focusing on month and year and we want to separate the column into two new variables.</p>

<pre><code class="language-crystal">reshaped.separate(<span class="s">&quot;quarter&quot;</span>, into: [<span class="s">&quot;Qtr&quot;</span>,<span class="s">&quot;Year&quot;</span>], sep: <span class="s">&quot;_&quot;</span>).print(<span class="s">&quot;Separated&quot;</span>, max_rows: <span class="n">12</span>)</code></pre>

<p>Output:</p>

<pre><code class="language-shell">Separated: 12 x 4
     country   growth   Qtr   Year
 1         A    0.030    q1   2017
 2         B    0.050    q1   2017
 3         C    0.010    q1   2017
 4         A    0.050    q2   2017
 5         B    0.070    q2   2017
 6         C    0.020    q2   2017
 7         A    0.040    q3   2017
 8         B    0.050    q3   2017
 9         C    0.010    q3   2017
10         A    0.030    q4   2017
11         B    0.020    q4   2017
12         C    0.040    q4   2017</code></pre>

<h4><a id="unite" class="anchor" href="#unite">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>unite()</h4>

<p>The <code>unite</code> function concatenate multiple columns into one.</p>

<pre><code class="language-crystal">separated.unite(<span class="s">&quot;Quarter&quot;</span>,[<span class="s">&quot;Qtr&quot;</span>,<span class="s">&quot;Year&quot;</span>], sep: <span class="s">&quot;_&quot;</span>).print(<span class="s">&quot;United&quot;</span>)</code></pre>

<p>Output:</p>

<pre><code class="language-shell">     country   growth   Quarter
 1         A    0.030   q1_2017
 2         B    0.050   q1_2017
 3         C    0.010   q1_2017
 4         A    0.050   q2_2017
 5         B    0.070   q2_2017
 6         C    0.020   q2_2017
 7         A    0.040   q3_2017
 8         B    0.050   q3_2017
 9         C    0.010   q3_2017
10         A    0.030   q4_2017
and 2 more rows</code></pre>

<hr/><h2><a id="installation" class="anchor" href="#installation">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Installation</h2>

<ol><li>Add the dependency to your <code>shard.yml</code>:</li></ol>

<pre><code class="language-yaml">   dependencies:
     crysda:
       github: naqvis/CrysDA</code></pre>

<ol><li>Run <code>shards install</code></li></ol>

<h2><a id="usage" class="anchor" href="#usage">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Usage</h2>

<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;crysda&quot;</span>

<span class="c"># Read tab-delimited data-frame from disk</span>
df <span class="o">=</span> <span class="t">Crysda</span>.read_csv(<span class="s">&quot;data/iris.txt&quot;</span>, separator: <span class="s">&#39;\t&#39;</span>)

<span class="c"># Read data-frame from URL</span>
df <span class="o">=</span> <span class="t">Crysda</span>.read_csv(<span class="s">&quot;http://url/file.csv&quot;</span>)

<span class="c"># Create data-frame in memory</span>
df <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;first_name&quot;</span>, <span class="s">&quot;last_name&quot;</span>, <span class="s">&quot;age&quot;</span>, <span class="s">&quot;weight&quot;</span>, <span class="s">&quot;adult&quot;</span>).values(
  <span class="s">&quot;Max&quot;</span>, <span class="s">&quot;Doe&quot;</span>, <span class="n">23</span>, <span class="n">55.8</span>, <span class="n">true</span>,
  <span class="s">&quot;Franz&quot;</span>, <span class="s">&quot;Smith&quot;</span>, <span class="n">23</span>, <span class="n">88.3</span>, <span class="n">true</span>,
  <span class="s">&quot;Horst&quot;</span>, <span class="s">&quot;Keanes&quot;</span>, <span class="n">12</span>, <span class="n">82.5</span>, <span class="n">false</span>,
)

<span class="c"># print rows</span>
df.print

<span class="c"># print structure of data-frame</span>
df.schema

<span class="c"># Subset columns with select/reject</span>
df.<span class="k">select</span>(<span class="s">&quot;last_name&quot;</span>, <span class="s">&quot;weight&quot;</span>)
df.reject(<span class="s">&quot;weight&quot;</span>, <span class="s">&quot;age&quot;</span>)
df.<span class="k">select</span>(<span class="o">&amp;</span>.ends_with?(<span class="s">&quot;name&quot;</span>))
df.select? { <span class="o">|</span>v<span class="o">|</span> v.<span class="k">is_a?</span>(<span class="t">Crysda</span><span class="t">::</span><span class="t">Int32Col</span>) }
df.select? { <span class="o">|</span>v<span class="o">|</span> v.name.starts_with?(<span class="s">&quot;foo&quot;</span>) }

<span class="c"># Subset rows with filter</span>
df.filter { <span class="o">|</span>e<span class="o">|</span> e.[<span class="s">&quot;age&quot;</span>] <span class="o">==</span> <span class="n">23</span> }
df.filter { <span class="o">|</span>e<span class="o">|</span> e.[<span class="s">&quot;weight&quot;</span>] <span class="o">&gt;</span> <span class="n">50</span> }
df.filter { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;first_name&quot;</span>].matching { <span class="o">|</span>e<span class="o">|</span> e.starts_with?(<span class="s">&quot;Ho&quot;</span>) } }

<span class="c"># Sort your data</span>
df.sort_by(<span class="s">&quot;age&quot;</span>)
<span class="c"># and add secondary sorting attribute as variadic param</span>
df.sort_by(<span class="s">&quot;age&quot;</span>, <span class="s">&quot;weight&quot;</span>)
<span class="c"># sort in descending order</span>
df.sort_desc_by(<span class="s">&quot;age&quot;</span>)
df.sort_by { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;weight&quot;</span>] }

<span class="c"># add columns with mutate</span>
<span class="c"># by adding constant values as new column</span>
df.add_column(<span class="s">&quot;salary_category&quot;</span>) { <span class="n">3</span> }

<span class="c"># by doing basic column arithmetics</span>
df.add_column(<span class="s">&quot;age_3y_later&quot;</span>) { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;age&quot;</span>] <span class="o">+</span> <span class="n">3</span> }

<span class="c"># Note: dataframes are immutable so we need to (re)assign results to preserve changes.</span>
new_df <span class="o">=</span> df.add_column(<span class="s">&quot;full_name&quot;</span>) { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;first_name&quot;</span>] <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> e[<span class="s">&quot;last_name&quot;</span>] }

<span class="c"># Also feel free to mix types</span>
df.add_column(<span class="s">&quot;user_id&quot;</span>) { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;last_name&quot;</span>] <span class="o">+</span> <span class="s">&quot;_id&quot;</span> <span class="o">+</span> e.row_num }

<span class="c"># add multiple columns at once</span>
df.add_columns(
  <span class="s">&quot;age_plus3&quot;</span>.<span class="k">with</span> { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;age&quot;</span>] <span class="o">+</span> <span class="n">3</span> },
  <span class="s">&quot;initials&quot;</span>.<span class="k">with</span> { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;first_name&quot;</span>].map(<span class="o">&amp;</span>.to_s[<span class="n">0</span>]).concatenate(e[<span class="s">&quot;last_name&quot;</span>].map(<span class="o">&amp;</span>.to_s[<span class="n">0</span>])) })

<span class="c"># Summarize</span>

<span class="c"># do simple cross tabulations</span>
df.count(<span class="s">&quot;age&quot;</span>, <span class="s">&quot;last_name&quot;</span>)

<span class="c"># or calculate single summary statistic</span>
df.summarize(<span class="s">&quot;min_age&quot;</span>) { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;age&quot;</span>].min }
<span class="c"># or</span>
df.summarize(
  <span class="s">&quot;min_age&quot;</span>.<span class="k">with</span> { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;age&quot;</span>].min },
  <span class="s">&quot;max_age&quot;</span>.<span class="k">with</span> { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;age&quot;</span>].max },
  <span class="s">&quot;mean_weight&quot;</span>.<span class="k">with</span> { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;weight&quot;</span>].mean },
)

<span class="c"># Group operations</span>
grouped_df <span class="o">=</span> df.group_by(<span class="s">&quot;age&quot;</span>) <span class="c"># or provide multiple grouping attributes</span>
grouped_df.summarize(
  <span class="s">&quot;mean_weight&quot;</span>.<span class="k">with</span> { <span class="o">|</span>e<span class="o">|</span> e[<span class="s">&quot;weight&quot;</span>].mean(remove_na: <span class="n">true</span>) },
  <span class="s">&quot;num_persons&quot;</span>.<span class="k">with</span> {<span class="o">|</span>e<span class="o">|</span> e.num_row}
)

<span class="c"># optionally ungroup the data</span>
grouped_df.ungroup.print

<span class="c"># Join operations</span>
a <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;name&quot;</span>, <span class="s">&quot;project_id&quot;</span>).values(
  <span class="s">&quot;Max&quot;</span>, <span class="s">&quot;P1&quot;</span>,
  <span class="s">&quot;Max&quot;</span>, <span class="s">&quot;P2&quot;</span>,
  <span class="s">&quot;Tom&quot;</span>, <span class="s">&quot;P3&quot;</span>
)

b <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;title&quot;</span>, <span class="s">&quot;project_id&quot;</span>).values(
  <span class="s">&quot;foo&quot;</span>, <span class="s">&quot;P1&quot;</span>,
  <span class="s">&quot;some_title&quot;</span>, <span class="s">&quot;P2&quot;</span>,
  <span class="s">&quot;alt_title&quot;</span>, <span class="s">&quot;P2&quot;</span>
)

a.left_join(b, by: <span class="s">&quot;project_id&quot;</span>).print
a.outer_join(b).print

df <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;foo&quot;</span>, <span class="s">&quot;bar&quot;</span>).values(
  <span class="s">&quot;a&quot;</span>, <span class="n">2</span>,
  <span class="s">&quot;b&quot;</span>, <span class="n">3</span>,
  <span class="s">&quot;c&quot;</span>, <span class="n">4</span>
)

<span class="c"># join on foo</span>
df.inner_join(df, by: <span class="s">&quot;foo&quot;</span>, suffices: {<span class="s">&quot;_1&quot;</span>, <span class="s">&quot;_2&quot;</span>}).tap <span class="k">do</span> <span class="o">|</span>d<span class="o">|</span>
  d.print
<span class="k">end</span>

<span class="c"># again but now join on bar. Join columns are expected to come first</span>
df.inner_join(df, <span class="s">&quot;bar&quot;</span>, {<span class="s">&quot;_1&quot;</span>, <span class="s">&quot;_2&quot;</span>})

<span class="c"># again but now join on nothing</span>
df.inner_join(df, <span class="o">[]</span> <span class="k">of</span> <span class="t">String</span>, {<span class="s">&quot;_1&quot;</span>, <span class="s">&quot;_2&quot;</span>})

<span class="c"># Reshape data</span>
df <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;person&quot;</span>, <span class="s">&quot;year&quot;</span>, <span class="s">&quot;weight&quot;</span>, <span class="s">&quot;sex&quot;</span>).values(
  <span class="s">&quot;max&quot;</span>, <span class="n">2014</span>, <span class="n">33.1</span>, <span class="s">&quot;M&quot;</span>,
  <span class="s">&quot;max&quot;</span>, <span class="n">2015</span>, <span class="n">32.3</span>, <span class="s">&quot;M&quot;</span>,
  <span class="s">&quot;max&quot;</span>, <span class="n">2016</span>, <span class="n">nil</span>, <span class="s">&quot;M&quot;</span>,
  <span class="s">&quot;anna&quot;</span>, <span class="n">2013</span>, <span class="n">33.5</span>, <span class="s">&quot;F&quot;</span>,
  <span class="s">&quot;anna&quot;</span>, <span class="n">2014</span>, <span class="n">37.3</span>, <span class="s">&quot;F&quot;</span>,
  <span class="s">&quot;anna&quot;</span>, <span class="n">2015</span>, <span class="n">39.2</span>, <span class="s">&quot;F&quot;</span>,
  <span class="s">&quot;anna&quot;</span>, <span class="n">2016</span>, <span class="n">39.9</span>, <span class="s">&quot;F&quot;</span>
)
df.schema
df.spread(<span class="s">&quot;year&quot;</span>, <span class="s">&quot;weight&quot;</span>).print

df <span class="o">=</span> <span class="t">Crysda</span>.dataframe_of(<span class="s">&quot;person&quot;</span>, <span class="s">&quot;property&quot;</span>, <span class="s">&quot;value&quot;</span>, <span class="s">&quot;sex&quot;</span>).values(
  <span class="s">&quot;max&quot;</span>, <span class="s">&quot;salary&quot;</span>, <span class="s">&quot;33.1&quot;</span>, <span class="s">&quot;M&quot;</span>,
  <span class="s">&quot;max&quot;</span>, <span class="s">&quot;city&quot;</span>, <span class="s">&quot;London&quot;</span>, <span class="s">&quot;M&quot;</span>,
  <span class="s">&quot;anna&quot;</span>, <span class="s">&quot;salary&quot;</span>, <span class="s">&quot;33.5&quot;</span>, <span class="s">&quot;F&quot;</span>,
  <span class="s">&quot;anna&quot;</span>, <span class="s">&quot;city&quot;</span>, <span class="s">&quot;Berlin&quot;</span>, <span class="s">&quot;F&quot;</span>
)
wide_df <span class="o">=</span> df.spread(<span class="s">&quot;property&quot;</span>, <span class="s">&quot;value&quot;</span>)

wide_df.gather(<span class="s">&quot;property&quot;</span>, <span class="s">&quot;value&quot;</span>, <span class="t">Crysda</span><span class="t">::</span><span class="t">ColumnSelector</span>.<span class="k">new</span> { <span class="o">|</span>x<span class="o">|</span> (x.except(<span class="s">&quot;person&quot;</span>)).and x.starts_with?(<span class="s">&quot;person&quot;</span>) })

wide_df.gather(<span class="s">&quot;property&quot;</span>, <span class="s">&quot;value&quot;</span>, <span class="t">Crysda</span><span class="t">::</span><span class="t">ColumnSelector</span>.<span class="k">new</span> { <span class="o">|</span>x<span class="o">|</span> x.except(<span class="s">&quot;person&quot;</span>) })

wide_df.gather(<span class="s">&quot;property&quot;</span>, <span class="s">&quot;value&quot;</span>, <span class="t">Crysda</span><span class="t">::</span><span class="t">ColumnSelector</span>.<span class="k">new</span> { <span class="o">|</span>x<span class="o">|</span> x.except(<span class="s">&quot;person&quot;</span>) })
  .tap <span class="k">do</span> <span class="o">|</span>wf<span class="o">|</span>
    wf.print
    annual_salary <span class="o">=</span> wf.filter { <span class="o">|</span>x<span class="o">|</span> (x[<span class="s">&quot;person&quot;</span>] <span class="o">==</span> <span class="s">&quot;anna&quot;</span>).and (x[<span class="s">&quot;property&quot;</span>] <span class="o">==</span> <span class="s">&quot;salary&quot;</span>) }
    annual_salary.print
  <span class="k">end</span></code></pre>

<p><strong>.....</strong></p>

<p>Unable to cover each and every functionality in this README. So refer to <code>specs</code> for more sample usages and API documentation for all available functionality.</p>

<h2><a id="development" class="anchor" href="#development">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Development</h2>

<p>To run all tests:</p>

<pre><code>crystal spec</code></pre>

<h2><a id="contributing" class="anchor" href="#contributing">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Contributing</h2>

<ol><li>Fork it (&lt;https://github.com/naqvis/Crysda/fork>)</li><li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li><li>Commit your changes (<code>git commit -am 'Add some feature'</code>)</li><li>Push to the branch (<code>git push origin my-new-feature</code>)</li><li>Create a new Pull Request</li></ol>

<h2><a id="contributors" class="anchor" href="#contributors">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Contributors</h2>

<ul><li><a href="https://github.com/naqvis" target="_blank">Ali Naqvi</a> - creator and maintainer</li></ul>


</div>
</body>
</html>
